[{"content":"One-day road trip across Garhwal\u0026rsquo;s Doon, Dhanaulti and Tehri.\nIt\u0026rsquo;s 9 o\u0026rsquo;clock on a November morning, but I\u0026rsquo;m surprised to see that Doon\u0026rsquo;s winter is still bearable this late in the year. After having breakfast and tea, we headed out for our first stop at Dhanaulti. At Ballupur Chowk, we took the route that goes via Garhi Cantonment, which eventually merges with the Mussoorie Road at Malsi. This route circumvents Doon\u0026rsquo;s busy Clock Tower and Rajpur Road.\nA view of the Doon Valley from a restaurant along the Mussoorie Road.\nWe continued along the Mussoorie Road until we reached JP Bend, a sharp turn that appears some distance before the multi-level car park at Kincraig. I\u0026rsquo;ve always been curious about the origins of Kincraig, a place that is difficult to locate on Google Maps and relatively unknown to anyone except the locals. According to some text I found, the name - no marks for guessing it was given by the British - was inspired by a place in Scotland. Prior to 1950, Kincraig was the last point accessible by vehicles, beyond which people had to travel on foot.\nAt JP Bend, we took the road that diverges towards Landour, which eventually leads us to Dhanaulti.\nA picturesque view from Burans Khand with a backdrop of white-topped mountains, quite possibly Yamunotri.\nAs a child, I had been to Eco Park, a popular attraction in Dhanaulti. However, upon our arrival, it seemed as though I had no recollection of it. I vaguely remembered an apple orchard being present somewhere in the vicinity of the park. My dad informed me that the orchard was a private estate, although open for visits, situated at the upper heights of the mountain where the park was located. If his memory served him right, there was a path to the orchard that began from inside the park and an another less trodden one that lay outside and away from it.\nDeodar trees are a usual sight across Dhanaulti.\nBeyond the Eco Park, there are several restaurants that serve refreshments. We stopped at one before leaving for Chamba, which is the entry point to Tehri.\nSurkhanda Devi Temple is located on the way. The stairs to the temple begin around an entrance arch right next to the road and lead to the top of the mountain where the temple is located. It is a nice little hike to the top and had been on my bucket list for a while. Since we were short on time, we couldn\u0026rsquo;t check it off that day. However, my mother felt that it would be appropriate for us to at least pay our respects at the entrance arch. Quickly getting out of our car, we went straight for the bell tied to the entrance arch, rang it, brought our palms together in a namaste, bowed our heads, and chanted \u0026lsquo;Jai Surkhanda Devi\u0026rsquo;.\nEn route to Tehri, we passed through Kanatal and Chamba. Chamba, in particular, seemed like a lively bustling town.\nWe finally reached Tehri Jheel (lake) at 2 in the afternoon. We seemed to have arrived at an opportune moment as there was an Acro Festival being held there. It featured boat riding, parasailing, jet skiing, and even paragliding from the top of the mountains. I was a little disappointed to learn that paragliding was not open to tourists but was strictly for experienced pilots who had apparently been invited from different countries by the organizers to take part in the Acro Paragliding competition.\nOverall, it was nice to see the government promoting tourism, especially to the outside world.\nVideo Boating at the Tehri lake.\nWhat we call the Tehri lake is a reservoir formed at the Sangam (confluence) of two rivers: the Bhagirathi River, flowing in from the northwest, and a much smaller Bhilangana River, flowing in from the east. At the confluence lies the Tehri Dam, which is powered by the reservoir. The river that comes out on the other end of the dam is still the Bhagirathi River, which eventually meets the Alaknanda River at Devprayag to form the mighty Ganga.\nPhotograph captured from a boat in Bhagirathi looking toward the hill that adjoins the Tehri Dam (bottom-right of the hill).\nIt was 4 o\u0026rsquo;clock in the evening and we thought it would be better to leave early to avoid driving at night, as much as possible by then.\nFor our way back, which would still go via Chamba, we took the Rishikesh-Chamba-Tehri Road that goes via Narendra Nagar and opens up at Rishikesh.\nA map with Tehri in the middle.\nA few kilometers behind Narendra Nagar lies a town named Agrakhal. Khal is a Garhwali word that refers to a hill with a flat top (closest english word: plateau). Many shops there were selling local produce, the most prominent of which was Adrak (ginger).\nSome produce bought from Agrakhal:\n(black) Bhatt Dal - makes for great Chutney\n(red) Unrefined Rice - still contains bran which is used in making oil\n(brown) Gaunth Dal - makes for great Parathas\n(yellow) Sabut Toor Dal Small restaurants serving tea and food had their kitchens facing outward toward the road. Something caught my eye: almost all of these had a pan of what is called Bhutwa - a stew of pieces of goat meat that had been cut from various parts of the goat. We ordered one plate, and while eating, I was only able to make out the pieces that tasted like liver. The rest of the bits and pieces tasted unusual to my tongue, which wasn\u0026rsquo;t privy to the various goat organs. Nevertheless, I finished the plate, thanked the owner Mr. Rawat, and we went on our way.\nBhutwa.\nNarendra Nagar has been on my bucket list of places to visit on account of the Palace of Garhwal Maharajas that is present in the town. Narendra Shah, after whom the town is named, reigned over the Tehri Garhwal Kingdom from 1913 to 1946. In 1919, he moved the capital of the Garhwal Kingdom from Tehri to the place which would become Narendra Nagar. I was slightly disappointed to hear that a resort named Ananda had taken the Palace\u0026rsquo;s place. To me, historical structures such as this Palace must be preserved so future generations can cling to their past. I hope the resort has preserved the original Palace structures and also put on display its history for visitors to appreciate. I shall visit it someday.\nDusk taking over the Agar village as seen from Agrakhal.\nAt Narendra Nagar, we abandoned the Rishikesh-Chamba-Tehri Road for a Dehradun bypass road that seemed to have been laid down quite recently. We reached home by 8 at night, thanks to Dad\u0026rsquo;s experience in driving on hilly roads.\n","permalink":"https://blog.shivammamgain.com/posts/2023/garhwal-doon-dhanaulti-tehri/","summary":"One-day road trip across Garhwal\u0026rsquo;s Doon, Dhanaulti and Tehri.","title":"Garhwal: Doon-Dhanaulti-Tehri"},{"content":"Been working heads down along with the team for the last couple of months. Our work is mostly around Retrieval-Augmented Generation. Personally, I had a lot of learnings around Machine Learning, especially Large Language Models like GPT.\nPart of our work was showcased at Microsoft Build 2023 (Archives for future readers). I\u0026rsquo;ve listed down sessions where our work was showcased or mentioned. I\u0026rsquo;ve also listed sessions that I really liked.\nSatya\u0026rsquo;s Keynote - Link AI dominated the keynote obviously. I recommend watching it to get a high-level idea of what\u0026rsquo;s in the store in the coming few weeks. There have been multiple teams grinding to release several features. Our team\u0026rsquo;s work is present on this slide (16:35 mark in the video):\nSpecifically these areas: Vector indexing, Retrieval Augmented Generation, Prompt workflows.\nFrom the keynote, I particularly liked this slide that has historical references that give an idea of what our understanding was of future technology back then:\nI\u0026rsquo;ve linked the first three:\nAs We May Think by Vannevar Bush, July 1945 Man-Computer Symbiosis by J. C. R. Licklider, March 1960 The Mother of All Demos by Douglas Engelbart, December 1968 Another interesting slide was a graph around GDP growth with references to revolutionary technological advancements:\nBuild and maintain your company Copilot with Azure ML and GPT-4 - Link Daniel Schneider and Seth Juarez demoed our team\u0026rsquo;s work. At 38:00 mark, Daniel shows how to create a Vector Index in PromptFlow:\nThe full session covers not just our work but also of others around us in AzureML. Great demo session overall. There was some adhoc work I did for Daniel\u0026rsquo;s Copilot demo. I created a websocket server for his Copilot, and a console client. He demoed it at 19:00 mark:\nLooking at the console client Seth remarks: \u0026ldquo;If it was 1987 and this is the interface we give to our customers\u0026hellip;\u0026rdquo; - me crying\nThe era of the AI Copilot - Link Delivered by Kevin Scott (Microsoft CTO), it explains what a Copilot is with a nice demo (code) at 35:30 mark. Greg Brockman (OpenAI Co-founder) was invited on stage for a QnA. Kevin also mentioned Harrison Chase (Creator of LangChain) who was present in the audience. Nice.\nState of GPT - Link My favorite session from the conference, delivered by Andrej Karpathy from OpenAI. I\u0026rsquo;ve been following his work for some time now. This session gives you an overview of the ecosystem that has come to exist around ChatGPT. It touches upon things like Chain-of-Thought prompting, AutoGPT, LangChain, etc. The best part is the explanation of how ChatGPT is trained. Deeply technical session. Loved it.\nBuilding AI solutions with Semantic Kernel - Link I\u0026rsquo;ve been using LangChain to write LLM based applications. Semantic Kernel by Microsoft is another alternative. A lot of overlaps between the two. Semantic Kernel was originally written in C# and has a Python package now.\nBuilding and using AI models responsibly - Link Generative models spew all kinds of things. What goes in and comes out of these models will need to be adjusted, for instance, to filter out harmful responses by LLMs. ResponsibleAI works in this area. I feel this problem is big enough that we might see startups focusing on just that.\nEnd Lot to learn.\n","permalink":"https://blog.shivammamgain.com/posts/2023/build-2023/","summary":"Microsoft Build 2023 and our team\u0026rsquo;s work","title":"//build/ 2023"},{"content":"Table-driven tests are great because they remove the need for duplicate testing setup for similar test cases. In following this approach, the input and the expected output of these test cases are conveniently placed in a list (the table).\nI’ve come across folks trying to write a table-driven test even though it increases the complexity of the test (anecdotal?). For such instances, separate tests for the test cases would’ve resulted in easier-to-understand code.\nTo demonstrate what I seen, here’s a sample HTTP handler that accepts a POST JSON request to create a TODO:\nfunc (c *Controller) CreateTODO(w http.ResponseWriter, r *http.Request) { // Is method allowed if r.Method != http.MethodPost { http.Error(w, \u0026#34;method is not POST\u0026#34;, http.StatusMethodNotAllowed) return } // Authentication call token := r.Header.Get(\u0026#34;AuthToken\u0026#34;) if !c.auth.IsAuthenticated(token) { http.Error(w, \u0026#34;unauthenticated\u0026#34;, http.StatusUnauthorized) return } // Decoding and validation todo := \u0026amp;TODO{} if err := json.NewDecoder(r.Body).Decode(todo); err != nil { http.Error(w, \u0026#34;invalid json: \u0026#34;+err.Error(), http.StatusBadRequest) return } if err := todo.Validate(); err != nil { http.Error(w, \u0026#34;invalid todo: \u0026#34;+err.Error(), http.StatusBadRequest) return } // Database call if err := c.db.CreateTODO(todo); err != nil { http.Error(w, \u0026#34;db error: \u0026#34;+err.Error(), http.StatusInternalServerError) return } respond(w, 201, \u0026#34;todo created\u0026#34;) } There are broadly 4 steps here before a TODO is considered to be successfully created:\nValidation of allowed method (POST) Authentication via an auth client Decoding of JSON from request body, and validation of fields Database INSERT call via a DB client/ORM The auth client c.auth and db client c.db are fields of the Controller struct.\ntype Controller struct { auth Authenticator db Database } type Authenticator interface { IsAuthenticated(token string) bool } type Database interface { CreateTODO(todo *TODO) error } Mocks can be generated for these interfaces to be used in unit tests.\nGood table-driven test The 3rd step (Decoding of JSON from request body, and validation of fields) from the above is a great candidate for table-driven tests because there could be multiple test inputs that can share the same testing setup. Here’s a small list of these:\nInvalid JSON in the request body Empty TODO name Empty TODO category All of these will result in Bad Requests, albeit different response bodies.\nA table-driven test for it would look something like this:\nfunc TestController_CreateTODO_BadRequestErrors(t *testing.T) { testCases := []struct { name string requestBody string expectedResponse string }{ {\u0026#34;invalid json\u0026#34;, `{\u0026#34;name\u0026#34;}`, \u0026#34;invalid json: invalid character \u0026#39;}\u0026#39; after object key\\n\u0026#34;}, {\u0026#34;empty name\u0026#34;, `{\u0026#34;name\u0026#34;: \u0026#34;\u0026#34;}`, \u0026#34;invalid todo: empty name\\n\u0026#34;}, {\u0026#34;empty category\u0026#34;, `{\u0026#34;name\u0026#34;: \u0026#34;task1\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;\u0026#34;}`, \u0026#34;invalid todo: empty category\\n\u0026#34;}, } for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { // Setup mocks c := gomock.NewController(t) defer c.Finish() auth := mock.NewMockAuthenticator(c) db := mock.NewMockDatabase(c) ctrl := api.NewController(auth, db) // Setup response recorder and request w := httptest.NewRecorder() rBody := bytes.NewBufferString(tc.requestBody) r := httptest.NewRequest(http.MethodPost, \u0026#34;http://example.com/todos\u0026#34;, rBody) r.Header.Add(\u0026#34;AuthToken\u0026#34;, testToken) // Expectations from mocks auth.EXPECT().IsAuthenticated(testToken).Return(true) // Call HTTP handler ctrl.CreateTODO(w, r) resp := w.Result() // Assertions assertEqual(t, 400, resp.StatusCode) assertEqual(t, tc.expectedResponse, responseBody(resp)) }) } } Full code for this snippet can be found in this file: controller_test.go.\nBad table-driven test If you try to write a table-driven test that covers 1st, 2nd, and 4th step, and the success case, it would look like this:\nfunc TestController_CreateTODO_BadTableDrivenTest(t *testing.T) { testCases := []struct { name string requestMethod string expectAuthCall bool authCallReturn bool expectDBCall bool dbCallReturn error expectedStatusCode int expectedResponse string }{ {\u0026#34;method not allowed\u0026#34;, http.MethodGet, false, false, false, nil, 405, \u0026#34;method is not POST\\n\u0026#34;}, {\u0026#34;unauthenticated\u0026#34;, http.MethodPost, true, false, false, nil, 401, \u0026#34;unauthenticated\\n\u0026#34;}, {\u0026#34;db error\u0026#34;, http.MethodPost, true, true, true, errors.New(\u0026#34;failed to commit txn\u0026#34;), 500, \u0026#34;db error: failed to commit txn\\n\u0026#34;}, {\u0026#34;success\u0026#34;, http.MethodPost, true, true, true, nil, 201, \u0026#34;todo created\u0026#34;}, } for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { // Setup mocks … // Setup response recorder and request … if tc.expectAuthCall { auth.EXPECT().IsAuthenticated(testToken).Return(tc.authCallReturn) } if tc.expectDBCall { db.EXPECT().CreateTODO(\u0026amp;api.TODO{\u0026#34;task1\u0026#34;, \u0026#34;cat1\u0026#34;}).Return(tc.dbCallReturn) } ctrl.CreateTODO(w, r) resp := w.Result() assertEqual(t, tc.expectedStatusCode, resp.StatusCode) assertEqual(t, tc.expectedResponse, responseBody(resp)) }) } } Notice in the table:\nrequestMethod is really needed only for the “method not allowed” case but has to be present even for other test cases. expectAuthCall and expectDBCall are needed to set mock expectations (EXPECT()) for certain test cases. authCallReturn and dbCallReturn are needed by EXPECT() calls. Overall, trying to fit multiple dissimilar cases into a table-driven test has resulted in a more complicated test.\nContrarily, if you were to separate these test cases into separate tests, then granted, there will be more code, but the tests will be easier to understand. For instance, if the “method not allowed” case was its own separate test, it would look something like this:\nfunc TestController_CreateTODO_MethodNotAllowed(t *testing.T) { // Setup mocks … // Setup response recorder and request … ctrl.CreateTODO(w, r) resp := w.Result() assertEqual(t, 405, resp.StatusCode) assertEqual(t, \u0026#34;method is not POST\\n\u0026#34;, responseBody(resp)) } The test case itself is simple because no client calls are expected, but adding it as a part of the table-driven test made it more complicated.\nIf this HTTP handler doesn’t look complex enough, then understand that most HTTP handlers are way more sophisticated. For instance, they might use more clients (besides auth and db) for external services (e.g. cache). Also, EXPECT() calls might require different arguments for different test cases, which will then need to be part of the table - making the table bigger.\nConclusion Obvious to many, but not to some: Avoid writing a table-driven test where test cases have different testing setups.\nWorking sample code for everything here can be found in this repo: github.com/shivamMg/table-driven-tests-go.\nAll tests shown here can be found in this file: controller_test.go.\nThank you Avinash for reviewing the post\u0026rsquo;s draft.\n","permalink":"https://blog.shivammamgain.com/posts/2022/bad-table-driven-tests-go/","summary":"When to avoid table-driven tests","title":"Go: Bad table-driven tests"},{"content":"My older blog was at Blogger.com. All of my older posts can be found at shivammg.blogspot.com.\n","permalink":"https://blog.shivammamgain.com/posts/2022/older-blog/","summary":"Older blog at shivammg.blogspot.com","title":"Older Blog"}]