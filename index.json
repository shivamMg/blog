[{"content":"Table-driven tests are great because they remove the need for duplicate testing setup for similar test cases. In following this approach, the input and the expected output of these test cases are conveniently placed in a list (the table).\nI’ve come across folks trying to write a table-driven test even though it increases the complexity of the test (anecdotal?). For such instances, separate tests for the test cases would’ve resulted in easier-to-understand code.\nTo demonstrate what I seen, here’s a sample HTTP handler that accepts a POST JSON request to create a TODO:\nfunc (c *Controller) CreateTODO(w http.ResponseWriter, r *http.Request) { // Is method allowed \tif r.Method != http.MethodPost { http.Error(w, \u0026#34;method is not POST\u0026#34;, http.StatusMethodNotAllowed) return } // Authentication call \ttoken := r.Header.Get(\u0026#34;AuthToken\u0026#34;) if !c.auth.IsAuthenticated(token) { http.Error(w, \u0026#34;unauthenticated\u0026#34;, http.StatusUnauthorized) return } // Decoding and validation \ttodo := \u0026amp;TODO{} if err := json.NewDecoder(r.Body).Decode(todo); err != nil { http.Error(w, \u0026#34;invalid json: \u0026#34;+err.Error(), http.StatusBadRequest) return } if err := todo.Validate(); err != nil { http.Error(w, \u0026#34;invalid todo: \u0026#34;+err.Error(), http.StatusBadRequest) return } // Database call \tif err := c.db.CreateTODO(todo); err != nil { http.Error(w, \u0026#34;db error: \u0026#34;+err.Error(), http.StatusInternalServerError) return } respond(w, 201, \u0026#34;todo created\u0026#34;) } There are broadly 4 steps here before a TODO is considered to be successfully created:\n Validation of allowed method (POST) Authentication via an auth client Decoding of JSON from request body, and validation of fields Database INSERT call via a DB client/ORM  The auth client c.auth and db client c.db are fields of the Controller struct.\ntype Controller struct { auth Authenticator db Database } type Authenticator interface { IsAuthenticated(token string) bool } type Database interface { CreateTODO(todo *TODO) error } Mocks can be generated for these interfaces to be used in unit tests.\nGood table-driven test The 3rd step (Decoding of JSON from request body, and validation of fields) from the above is a great candidate for table-driven tests because there could be multiple test inputs that can share the same testing setup. Here’s a small list of these:\n Invalid JSON in the request body Empty TODO name Empty TODO category  All of these will result in Bad Requests, albeit different response bodies.\nA table-driven test for it would look something like this:\nfunc TestController_CreateTODO_BadRequestErrors(t *testing.T) { testCases := []struct { name string requestBody string expectedResponse string }{ {\u0026#34;invalid json\u0026#34;, `{\u0026#34;name\u0026#34;}`, \u0026#34;invalid json: invalid character \u0026#39;}\u0026#39; after object key\\n\u0026#34;}, {\u0026#34;empty name\u0026#34;, `{\u0026#34;name\u0026#34;: \u0026#34;\u0026#34;}`, \u0026#34;invalid todo: empty name\\n\u0026#34;}, {\u0026#34;empty category\u0026#34;, `{\u0026#34;name\u0026#34;: \u0026#34;task1\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;\u0026#34;}`, \u0026#34;invalid todo: empty category\\n\u0026#34;}, } for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { // Setup mocks \tc := gomock.NewController(t) defer c.Finish() auth := mock.NewMockAuthenticator(c) db := mock.NewMockDatabase(c) ctrl := api.NewController(auth, db) // Setup response recorder and request \tw := httptest.NewRecorder() rBody := bytes.NewBufferString(tc.requestBody) r := httptest.NewRequest(http.MethodPost, \u0026#34;http://example.com/todos\u0026#34;, rBody) r.Header.Add(\u0026#34;AuthToken\u0026#34;, testToken) // Expectations from mocks \tauth.EXPECT().IsAuthenticated(testToken).Return(true) // Call HTTP handler \tctrl.CreateTODO(w, r) resp := w.Result() // Assertions \tassertEqual(t, 400, resp.StatusCode) assertEqual(t, tc.expectedResponse, responseBody(resp)) }) } } Full code for this snippet can be found in this file: controller_test.go.\nBad table-driven test If you try to write a table-driven test that covers 1st, 2nd, and 4th step, and the success case, it would look like this:\nfunc TestController_CreateTODO_BadTableDrivenTest(t *testing.T) { testCases := []struct { name string requestMethod string expectAuthCall bool authCallReturn bool expectDBCall bool dbCallReturn error expectedStatusCode int expectedResponse string }{ {\u0026#34;method not allowed\u0026#34;, http.MethodGet, false, false, false, nil, 405, \u0026#34;method is not POST\\n\u0026#34;}, {\u0026#34;unauthenticated\u0026#34;, http.MethodPost, true, false, false, nil, 401, \u0026#34;unauthenticated\\n\u0026#34;}, {\u0026#34;db error\u0026#34;, http.MethodPost, true, true, true, errors.New(\u0026#34;failed to commit txn\u0026#34;), 500, \u0026#34;db error: failed to commit txn\\n\u0026#34;}, {\u0026#34;success\u0026#34;, http.MethodPost, true, true, true, nil, 201, \u0026#34;todo created\u0026#34;}, } for _, tc := range testCases { t.Run(tc.name, func(t *testing.T) { // Setup mocks … \t// Setup response recorder and request …  if tc.expectAuthCall { auth.EXPECT().IsAuthenticated(testToken).Return(tc.authCallReturn) } if tc.expectDBCall { db.EXPECT().CreateTODO(\u0026amp;api.TODO{\u0026#34;task1\u0026#34;, \u0026#34;cat1\u0026#34;}).Return(tc.dbCallReturn) } ctrl.CreateTODO(w, r) resp := w.Result() assertEqual(t, tc.expectedStatusCode, resp.StatusCode) assertEqual(t, tc.expectedResponse, responseBody(resp)) }) } } Notice:\n requestMethod is really needed only for the “method not allowed” case but has to be set even for other test cases. expectAuthCall and expectDBCall are needed to set mock expectations (EXPECT()) for certain test cases. authCallReturn and dbCallReturn are needed by EXPECT() calls.  Overall, trying to fit multiple dissimilar cases into a table-driven test has resulted in a more complicated test.\nContrarily, if you were to separate these test cases into separate tests, then granted, there will be more code, but the tests will be easier to understand. For instance, if the “method not allowed” case was its own separate test, it would look something like this:\nfunc TestController_CreateTODO_MethodNotAllowed(t *testing.T) { // Setup mocks … \t// Setup response recorder and request …  ctrl.CreateTODO(w, r) resp := w.Result() assertEqual(t, 405, resp.StatusCode) assertEqual(t, \u0026#34;method is not POST\\n\u0026#34;, responseBody(resp)) } The test case itself is simple because no client calls are expected, but adding it as a part of the table-driven test made it more complicated.\nIf this sample doesn’t look complex enough, then understand that most HTTP handlers are way more sophisticated. For instance, they might use more clients (besides auth and db) for external services (e.g. cache). Also, EXPECT() calls might require different arguments for different test cases, which will then need to be part of the table - making the table bigger.\nConclusion Obvious to many, but not to some: Avoid writing a table-driven test where test cases have different testing setups.\nWorking sample code for everything here can be found in this repo: github.com/shivamMg/table-driven-tests-go.\nAll tests shown here can be found in this file: controller_test.go.\n ","permalink":"https://blog.shivammamgain.com/posts/2022/table-driven-tests-go/","summary":"When to avoid table-driven tests","title":"Go: Bad table-driven tests"},{"content":"My older blog was at Blogger.com. All of my older posts can be found at shivammg.blogspot.com.\n ","permalink":"https://blog.shivammamgain.com/posts/2022/older-blog/","summary":"Older blog at shivammg.blogspot.com","title":"Older Blog"}]